(ns speculative.impl.syms
  (:require [clojure.set] [clojure.string]))

(def all-syms-clj '#{clojure.core/max clojure.core/inc clojure.core/remove clojure.set/intersection clojure.core/next clojure.core/min-key clojure.string/starts-with? clojure.set/project clojure.core// clojure.core/+ clojure.core/get clojure.set/index clojure.core/get-in clojure.core/* clojure.core/min clojure.core/assoc clojure.core/assoc-in clojure.core/re-groups clojure.core/reduce clojure.core/select-keys clojure.core/first clojure.core/= clojure.core/dec clojure.core/not clojure.string/ends-with? clojure.core/interpose clojure.core/every? clojure.core/subs clojure.core/range clojure.core/some clojure.core/keep clojure.core/rest clojure.core/cons clojure.core/re-seq clojure.core/merge clojure.core/re-pattern clojure.set/rename-keys clojure.core/some? clojure.core/into clojure.set/difference clojure.core/str clojure.core/conj clojure.set/superset? clojure.core/count clojure.core/apply clojure.core/re-matcher clojure.core/filter clojure.core/group-by clojure.set/subset? clojure.core/re-matches clojure.core/partial clojure.core/not-any? clojure.core/pop clojure.set/union clojure.core/re-find clojure.core/last clojure.core/not-every? clojure.core/- clojure.core/reset! clojure.core/nth clojure.set/rename clojure.set/map-invert clojure.core/flatten clojure.core/max-key clojure.core/juxt clojure.core/map clojure.core/peek clojure.set/join clojure.set/select clojure.core/find clojure.core/merge-with clojure.core/fnil clojure.core/swap!})
(def all-syms-cljs '#{cljs.core/keep cljs.core/some? cljs.core/rest clojure.set/intersection cljs.core/str cljs.core/re-seq clojure.string/starts-with? clojure.set/project clojure.set/index cljs.core/filter cljs.core/= cljs.core/dec cljs.core/not-any? cljs.core/re-matches cljs.core/partial cljs.core/count cljs.core/reduce cljs.core/apply cljs.core/group-by cljs.core/last cljs.core/pop cljs.core/max-key clojure.string/ends-with? cljs.core/find cljs.core/fnil cljs.core/merge-with cljs.core/- cljs.core/into cljs.core/reset! cljs.core/conj cljs.core/re-pattern cljs.core/juxt cljs.core/peek cljs.core/map cljs.core// cljs.core/get-in clojure.set/rename-keys cljs.core/swap! cljs.core/get cljs.core/flatten cljs.core/remove clojure.set/difference cljs.core/* cljs.core/min cljs.core/re-find clojure.set/superset? cljs.core/not-every? cljs.core/nth cljs.core/max clojure.set/subset? cljs.core/next cljs.core/select-keys cljs.core/not cljs.core/cons cljs.core/assoc cljs.core/interpose clojure.set/union cljs.core/assoc-in cljs.core/range clojure.set/rename clojure.set/map-invert cljs.core/first clojure.set/join cljs.core/subs cljs.core/merge cljs.core/+ cljs.core/every? clojure.set/select cljs.core/inc cljs.core/some cljs.core/min-key})
(def blacklist-clj (set '[clojure.core/not clojure.core/some? clojure.core/str clojure.core/= clojure.core/get]))
(def blacklist-cljs '#{cljs.core/some? cljs.core/str cljs.core/= cljs.core/apply cljs.core/get cljs.core/next cljs.core/not})
(def instrumentable-syms-clj '#{clojure.core/max clojure.core/inc clojure.core/remove clojure.set/intersection clojure.core/next clojure.core/min-key clojure.string/starts-with? clojure.set/project clojure.core// clojure.core/+ clojure.set/index clojure.core/get-in clojure.core/* clojure.core/min clojure.core/assoc clojure.core/assoc-in clojure.core/re-groups clojure.core/reduce clojure.core/select-keys clojure.core/first clojure.core/dec clojure.string/ends-with? clojure.core/interpose clojure.core/every? clojure.core/subs clojure.core/range clojure.core/some clojure.core/keep clojure.core/rest clojure.core/cons clojure.core/re-seq clojure.core/merge clojure.core/re-pattern clojure.set/rename-keys clojure.core/into clojure.set/difference clojure.core/conj clojure.set/superset? clojure.core/count clojure.core/apply clojure.core/re-matcher clojure.core/filter clojure.core/group-by clojure.set/subset? clojure.core/re-matches clojure.core/partial clojure.core/not-any? clojure.core/pop clojure.set/union clojure.core/re-find clojure.core/last clojure.core/not-every? clojure.core/- clojure.core/reset! clojure.core/nth clojure.set/rename clojure.set/map-invert clojure.core/flatten clojure.core/max-key clojure.core/juxt clojure.core/map clojure.core/peek clojure.set/join clojure.set/select clojure.core/find clojure.core/merge-with clojure.core/fnil clojure.core/swap!})
(def instrumentable-syms-cljs '#{cljs.core/keep cljs.core/rest clojure.set/intersection cljs.core/re-seq clojure.string/starts-with? clojure.set/project clojure.set/index cljs.core/filter cljs.core/dec cljs.core/not-any? cljs.core/re-matches cljs.core/partial cljs.core/count cljs.core/reduce cljs.core/group-by cljs.core/last cljs.core/pop cljs.core/max-key clojure.string/ends-with? cljs.core/find cljs.core/fnil cljs.core/merge-with cljs.core/- cljs.core/into cljs.core/reset! cljs.core/conj cljs.core/re-pattern cljs.core/juxt cljs.core/peek cljs.core/map cljs.core// cljs.core/get-in clojure.set/rename-keys cljs.core/swap! cljs.core/flatten cljs.core/remove clojure.set/difference cljs.core/* cljs.core/min cljs.core/re-find clojure.set/superset? cljs.core/not-every? cljs.core/nth cljs.core/max clojure.set/subset? cljs.core/select-keys cljs.core/cons cljs.core/assoc cljs.core/interpose clojure.set/union cljs.core/assoc-in cljs.core/range clojure.set/rename clojure.set/map-invert cljs.core/first clojure.set/join cljs.core/subs cljs.core/merge cljs.core/+ cljs.core/every? clojure.set/select cljs.core/inc cljs.core/some cljs.core/min-key})
